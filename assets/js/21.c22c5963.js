(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{420:function(a,t,s){"use strict";s.r(t);var e=s(2),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"js异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js异步"}},[a._v("#")]),a._v(" js异步")]),a._v(" "),t("h2",{attrs:{id:"async-await-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await-是什么"}},[a._v("#")]),a._v(" async/await 是什么")]),a._v(" "),t("p",[a._v("async/await其实是Promise的语法糖，它能实现的效果都能用then链来实现，这也和我们之前提到的一样，它是为优化then链而开发出来的")]),a._v(" "),t("p",[a._v("async声明一个异步函数，await等待异步结果，把以前then链的结果放到直接放在await")]),a._v(" "),t("p",[a._v("如果等待的是Promise对象，则返回Promise的处理结果；如果是其他值，则返回该值本身")]),a._v(" "),t("h2",{attrs:{id:"async-await-相比于promise的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await-相比于promise的优势"}},[a._v("#")]),a._v(" async/await 相⽐于Promise的优势")]),a._v(" "),t("p",[a._v("代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅")]),a._v(" "),t("p",[a._v("错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余")]),a._v(" "),t("p",[a._v("调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的『每⼀步』。")])])}),[],!1,null,null,null);t.default=r.exports}}]);