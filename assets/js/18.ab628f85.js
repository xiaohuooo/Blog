(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{417:function(t,r,a){"use strict";a.r(r);var v=a(2),e=Object(v.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"js基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[t._v("#")]),t._v(" js基础")]),t._v(" "),r("h2",{attrs:{id:"谈谈你对原型链的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对原型链的理解"}},[t._v("#")]),t._v(" 谈谈你对原型链的理解")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pic2.zhimg.com/v2-6d5a69857e2f723e62b7e5ccd1f6dbc9_r.jpg",alt:""}})]),t._v(" "),r("p",[t._v("构造函数new出来一个对象，而每个对象都有一个constructor属性，该属性指向创建该实例的构造函数，构造函数的prototype属性是这个new出来的实例化对象的原型，实例对象通过__proto__或者object.getPrototype的方法获取原型。")]),t._v(" "),r("p",[t._v("从一个实例对象向上找有一个构造实例的原型对象，这个原型对象又有构造它的上一级原型对象，如此一级一级的关系链，就构成了原型链。原型链的最顶端就是Object.prototype")]),t._v(" "),r("h2",{attrs:{id:"如何判断是否是数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何判断是否是数组"}},[t._v("#")]),t._v(" 如何判断是否是数组")]),t._v(" "),r("p",[t._v("1、使用“Array.isArray(数组对象)”语句来判断，如果是数组则返回true")]),t._v(" "),r("blockquote",[r("p",[t._v("Array.isArray(a);//true")])]),t._v(" "),r("p",[t._v("2、使用“数组对象.constructor===Array”语句来判断。")]),t._v(" "),r("blockquote",[r("p",[t._v("a.constructor === Array;//true")])]),t._v(" "),r("p",[t._v("3、使用“数组对象 instanceof Array”语句来判断。")]),t._v(" "),r("blockquote",[r("p",[t._v("a instanceof Array; //true")])]),t._v(" "),r("p",[t._v("4、 Object.prototype.toString().call()")]),t._v(" "),r("blockquote",[r("p",[t._v("Object.prototype.toString.call(a) === '[object Array]';//true")])]),t._v(" "),r("h2",{attrs:{id:"es6模块与commonjs模块有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es6模块与commonjs模块有什么区别"}},[t._v("#")]),t._v(" ES6模块与CommonJS模块有什么区别")]),t._v(" "),r("p",[r("em",[t._v("一、区别：")])]),t._v(" "),r("p",[t._v("1.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")]),t._v(" "),r("p",[t._v("2.CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。")]),t._v(" "),r("p",[t._v("3.CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤,即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。")]),t._v(" "),r("p",[t._v("4.import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。")]),t._v(" "),r("p",[r("em",[t._v("二、共同点：")])]),t._v(" "),r("p",[t._v("1.CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。")]),t._v(" "),r("h2",{attrs:{id:"聊一聊如何在javascript中实现不可变对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#聊一聊如何在javascript中实现不可变对象"}},[t._v("#")]),t._v(" 聊⼀聊如何在JavaScript中实现不可变对象")]),t._v(" "),r("p",[t._v("可变对象")]),t._v(" "),r("p",[t._v("我们知道，JavaScript中对象是弱类型的。一般情况下，可以不受限制的为对象添加属性，修改属性，删除属性。大部分情况下，我们使用的都是可变对象。")]),t._v(" "),r("p",[t._v("不可变对象")]),t._v(" "),r("p",[t._v("对应的，我们不希望代码中某些对象被任意修改，比如添加、修改、删除等。这就是我们的不可变对象。JavaScript为我们提供了一些原生方法，借助它们可以讲一些可变对象转变成不可变对象。一共有三种：")]),t._v(" "),r("ul",[r("li",[t._v("Object.preventExtensions（不可扩展）")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.preventExtensions() 可以使一个对象不可再添加新的属性，参数为目标对象，返回修改后的对象。")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.isExtensible() 可以判断一个对象是否可扩展，即是否可以添加新的属性。参数是目标对象，返回布尔值， true 代表可扩展，false 不可扩展。")])]),t._v(" "),r("ul",[r("li",[t._v("Object.seal（密封）")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.seal() 可以使一个对象无法添加新属性的同时，也无法删除旧属性。参数是目标对象，返回修改后的对象。")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.isSealed() 可以检测一个对象是否密封，即是否可以增删属性。参数是目标对象，返回布尔值，true 代表被密封不可增删属性，false 代表没被密封可增删属性。")])]),t._v(" "),r("ul",[r("li",[t._v("Object.freeze（冻结）。")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.freeze() 可以使对象一个对象不能再添加新属性，也不可以删除旧属性，且不能修改属性的值。参数是目标对象，返回修改后的对象。")])]),t._v(" "),r("blockquote",[r("p",[t._v("Object.isFrozen() 可以检测一个对象是否冻结，即是否可以增删改。参数是目标对象，返回布尔值，true 表示已经冻结不可再增删改，false 反之。")])]),t._v(" "),r("h2",{attrs:{id:"javascript的参数是按照什么方式传递的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript的参数是按照什么方式传递的"}},[t._v("#")]),t._v(" JavaScript的参数是按照什么⽅式传递的")]),t._v(" "),r("p",[t._v("由于js中存在复杂类型和基本类型，对于基本类型而言，是按值传递的\n复杂类型是按引⽤传递的.")]),t._v(" "),r("h2",{attrs:{id:"js有哪些类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js有哪些类型"}},[t._v("#")]),t._v(" js有哪些类型")]),t._v(" "),r("p",[t._v("基本类型 string number boolean undefined null symbol bigint")]),t._v(" "),r("p",[t._v("复杂类型  array object function class")]),t._v(" "),r("h2",{attrs:{id:"为什么会有bigint的提案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么会有bigint的提案"}},[t._v("#")]),t._v(" 为什么会有BigInt的提案")]),t._v(" "),r("p",[t._v("BigInt是JavaScript中的一个新的原始类型，可以用任意精度表示整数。使用BigInt，即使超出JavaScript Number 的安全整数限制，也可以安全地存储和操作大整数。")]),t._v(" "),r("p",[t._v("JavaScript中的基本数据类Number是双精度浮点数，它可以表示的最大安全范围是正负的2的53次方减一。对安全整数范围以外的整数（即从Number.MIN_SAFE_INTEGER到Number.MAX_SAFE_INTEGER）的任何计算可能会失去精度。出于这个原因，我们只能依靠安全范围内的数字整数值。")]),t._v(" "),r("h2",{attrs:{id:"null与undefined的区别是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#null与undefined的区别是什么"}},[t._v("#")]),t._v(" null与undefined的区别是什么")]),t._v(" "),r("p",[t._v("null 是定义变量 但是未赋值")]),t._v(" "),r("p",[t._v("undefined 是未定义变量")]),t._v(" "),r("h2",{attrs:{id:"_0-1-0-2为什么不等于0-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2为什么不等于0-3"}},[t._v("#")]),t._v(" 0.1+0.2为什么不等于0.3")]),t._v(" "),r("ul",[r("li",[t._v("因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。")]),t._v(" "),r("li",[t._v("js中的Number类型遵循IEEE754标准，在IEEE754标准的64位浮点数相加，因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差。")]),t._v(" "),r("li",[t._v("小数转化为IEEE754的过程：先转化为二进制的形式，然后再用科学计数法表示，接着把通过科学计数法表示的二进制数用IEEE754标准表示。")])]),t._v(" "),r("h2",{attrs:{id:"类型转换的规则有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型转换的规则有哪些"}},[t._v("#")]),t._v(" 类型转换的规则有哪些")]),t._v(" "),r("p",[t._v("js的类型转换只有三种类型的转换: to string, to boolean, to number,")]),t._v(" "),r("p",[t._v("三种类型转换当中, 分为两大块: 显式类型转换和隐式类型转换.\n显式类型转换是隐式类型转换的基础, 到后面你会发现, 隐式类型转换就是在操作符的作用下进行显式类型转换")]),t._v(" "),r("h2",{attrs:{id:"类型转换的原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型转换的原理是什么"}},[t._v("#")]),t._v(" 类型转换的原理是什么")]),t._v(" "),r("p",[t._v("ECMAScript定义的了4个有关类型转换抽象操作，它们在javascript引擎内部使用，进行类型转换。我们不能直接调用这些方法，但是了解这些函数有利于我们理解类型转换的原理。")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("ToPrimitive ( input [ , PreferredType ] )：将input转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number或 String。")])]),t._v(" "),r("li",[r("p",[t._v("ToBoolean ( argument )：")])]),t._v(" "),r("li",[r("p",[t._v("ToNumber ( argument )：")])]),t._v(" "),r("li",[r("p",[t._v("ToString ( argument )：")])])]),t._v(" "),r("h2",{attrs:{id:"js常用数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js常用数据结构"}},[t._v("#")]),t._v(" JS常用数据结构")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/7074249087498846222#heading-34",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构"),r("OutboundLink")],1)]),t._v(" "),r("ol",[r("li",[t._v("数组")])]),t._v(" "),r("p",[t._v("数组（Array）是 js语言中自带的一类数据结构，原生提供跟多方便快捷好用的方式和属性，数组的数据结构是一种最最常见的线性数据结构；")]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("栈")])]),t._v(" "),r("p",[t._v("栈（stack）是一种 后进先出（LIFO）的常见数据结构；\n数组的线性结构可以方便的在数组的 任意位置 插入和删除数据，但有些应用场景需要堆这中任意性加以限制，栈和队列 就是比较常见的受限的线性数据结构，都有一些特定的应用场景；\njs中没有原生的栈数据结构，需要自行封装使用；")]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("队列")])]),t._v(" "),r("p",[t._v("队列（Queue）是一种 先进先出(FIFO) 的常见数据结构，是另一种比较常见的受限的线性数据结构。 js中没有原生的队列数据结构，需要自行封装使用；")]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("优先队列")])]),t._v(" "),r("p",[t._v("优先队列（PriorityQueue）是一种改进式的队列数据结构；普通队列插入一个元素，数数据会被放在后端，并且需要前面所有的元素都处理完成之后才处理这个元素；优先级队列是在插入一个元素的时候会考虑该数据的优先级；")]),t._v(" "),r("ol",{attrs:{start:"5"}},[r("li",[t._v("单向链表")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67bbaa94a500476ab8a2083c404b979b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?",alt:""}})]),t._v(" "),r("p",[t._v("链表（LinkedList）是不同于数组的另一种非常常见的用于存储数据的线性数据结构；\n链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同；\n链表不同于数组，链表中的元素在内存中不必是连续的空间；\n链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针或者连接)组成；")]),t._v(" "),r("ol",{attrs:{start:"6"}},[r("li",[t._v("双向链表")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb2c3cbf47042df83c8fcd23774cfa1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?",alt:""}})]),t._v(" "),r("p",[t._v("双向链表（LinkedList）是不同于数组的另一种非常常见的用于存储数据的线性数据结构；\n双向链表和数组一样，可以用于存储一系列的元素，但是双向链表和数组的实现机制完全不同；\n双向链表不同于数组，双向链表中的元素在内存中不必是连续的空间；\n双向链表的每个元素由一个存储元素本身的节点、一个指向下一个元素的引用 和 一个指向上一个元素的引用 (有些语言称为指针或者连接)组成；")]),t._v(" "),r("ol",{attrs:{start:"7"}},[r("li",[t._v("集合结构")])]),t._v(" "),r("p",[t._v("集合通常是由一组无序，不能重复的元素构成\n集合和数学中的集合名词比较相似，但是数学中的集合范围更大一些，也允许集合中的元素重复\n在计算机中，集合通常表示的结构中元素是不允许重复的\n集合不同于对象，在于集合只是 数据值 的集合，而对象是由键值对组成的数据集合，键名不可重复。")]),t._v(" "),r("ol",{attrs:{start:"8"}},[r("li",[t._v("字典结构")])]),t._v(" "),r("p",[t._v("数组 - 集合 - 字典类型的数据结构几乎在所有的高级编程语言中都有默认提供。javascript 语言在 es6 之后也提供了 map 这个字典类型的数据结构。字典的数据结构类似于对象，都是存放 键值对 结构的数据，只是 es6 的字典类型数据，其中的键key 可以是其他的数据类型，而对象object类型的键key只能是字符串类型。")]),t._v(" "),r("ol",{attrs:{start:"9"}},[r("li",[t._v("哈希表")])]),t._v(" "),r("p",[t._v("哈希表 通常是基于 数组 进行实现的。")])])}),[],!1,null,null,null);r.default=e.exports}}]);